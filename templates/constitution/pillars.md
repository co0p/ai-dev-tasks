# The 6 Pillars of Modern Software Engineering

A strong constitution covers the following pillars, guiding decision-making across architecture, implementation, and trade-offs:

1. **Delivery Velocity**
   - How fast to ship vs. how polished? Iteration philosophy, MVP definition, acceptable quality thresholds.
   - Guides: Feature scope, when to refactor, release cadence

2. **Test Strategy**
   - What to test, when to test, how much coverage is enough?
   - Guides: Test writing, refactoring confidence, deployment decisions

3. **Design Integrity**
   - How to structure code? Dependency rules, SOLID principles, architectural boundaries.
   - Guides: Where to put logic, when to create abstractions, module boundaries

4. **Simplicity First**
   - When to add abstraction? YAGNI application, refactoring triggers, complexity tolerance.
   - Guides: Premature optimization, abstraction timing, code evolution

5. **Technical Debt Boundaries**
   - When are shortcuts acceptable? How to track and pay down debt?
   - Guides: Shortcut decisions, refactoring priority, quality bar

6. **Dependency Discipline**
   - When to add libraries? How to isolate third-party code? Framework philosophy.
   - Guides: Library selection, vendor coupling, upgrade strategy
